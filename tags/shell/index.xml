<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>shell on Awesome</title>
    <link>https://csyakamoz.github.io/tags/shell/</link>
    <description>Recent content in shell on Awesome</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 22 Jan 2021 00:19:44 +0800</lastBuildDate><atom:link href="https://csyakamoz.github.io/tags/shell/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Shell 零碎笔记</title>
      <link>https://csyakamoz.github.io/post/2021/01/22/shell-%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 22 Jan 2021 00:19:44 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/2021/01/22/shell-%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0/</guid>
      <description>命令补全 官方文档: man bash, 按 /, 输入 Programmable Completion 回车
团子的小窝 - 编写 Bash 补全脚本
如何编写 bash 自动补全脚本
检查某命令是否存在 来源: How can I check if a program exists from a Bash script?
1command -v &amp;lt;the_command&amp;gt; 例子:
1if ! command -v COMMAND &amp;amp;&amp;gt; /dev/null 2then 3 echo &amp;#34;COMMAND could not be found&amp;#34; 4 exit 5fi  &amp;amp;&amp;gt; 的意思可见: What are the shell&amp;rsquo;s control and redirection operators? or What&amp;rsquo;s the accurate meaning of “exec &amp;amp;&amp;gt;/var/log/a.</description>
    </item>
    
    <item>
      <title>Shell 基础</title>
      <link>https://csyakamoz.github.io/post/2020/09/09/shell-%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Wed, 09 Sep 2020 11:35:19 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/2020/09/09/shell-%E5%9F%BA%E7%A1%80/</guid>
      <description>Manual Bash Reference Manual
Lint  ShellCheck, a static analysis tool for shell scripts
 建议使用 ShellCheck, 以检查脚本中潜在的问题
Shebang shebang 即 #! , 其后面跟的是解释当前脚本的解释器路径
e.g.
 #!/bin/bash #!/usr/bin/bash #!/usr/bin/env bash  个人习惯用 #!/usr/bin/env NAME 而不是 #!/usr/bin/NAME
原因请看此：Why is it better to use “#!/usr/bin/env NAME” instead of “#!/path/to/NAME” as my shebang?
变量 定义 variable=value
 不需要指定变量类型，即不需要说明是整型类型，还是字符串类型等等 等号两侧不能有空格  使用  $variable ${variable}  {} 是可选的，但建议加上，{} 是为了帮助解释器识别变量的边界
1for skill in Ada Coffee Action Java; do 2 echo &amp;#34;I am good at ${skill}Script&amp;#34; 3done 如果不给 skill 加上花括号，解释器会把 skillScript 当作变量，在上面的情况下，其值为空</description>
    </item>
    
    <item>
      <title>Shell 序列表达式</title>
      <link>https://csyakamoz.github.io/post/2020/09/09/shell-%E5%BA%8F%E5%88%97%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Wed, 09 Sep 2020 11:18:01 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/2020/09/09/shell-%E5%BA%8F%E5%88%97%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>格式：{FIRST..LAST[..INCREMENT]}
FIRST 和 LAST 是必需的，用 .. 分隔，中间没有空格，INCREMENT 是可选滴
Example 1echo {1..3} # 1 2 3 2 3echo {3..1} # 3 2 1 4 5echo {0..20..5} # 0 5 10 15 20 6 7echo 0{8..10} # 08 09 010 8 9echo {08..10} # 08 09 10 10 11echo {a..f} # a b c d e f 12 13echo {f..a} # f e d c b a 14 15echo T-{a..f}-T # T-a-T T-b-T T-c-T T-d-T T-e-T T-f-T 16 17echo {A.</description>
    </item>
    
    <item>
      <title>Shell 按行处理文本</title>
      <link>https://csyakamoz.github.io/post/2020/09/09/shell-%E6%8C%89%E8%A1%8C%E5%A4%84%E7%90%86%E6%96%87%E6%9C%AC/</link>
      <pubDate>Wed, 09 Sep 2020 11:15:00 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/2020/09/09/shell-%E6%8C%89%E8%A1%8C%E5%A4%84%E7%90%86%E6%96%87%E6%9C%AC/</guid>
      <description>内容来源：【Shell 脚本】逐行处理文本文件
read 1cat data.dat | while read line 2do 3 echo &amp;#34;${line}&amp;#34; 4done 5 6# or 7 8while read line 9do 10 echo &amp;#34;${line}&amp;#34; 11done &amp;lt; data.dat awk 1cat data.dat | awk &amp;#39;{print $0}&amp;#39; for &amp;hellip; in &amp;hellip; for var in content 表示变量 var 在 content 中循环取值，取值的分隔符由 ${IFS} 确定
1for line in $(cat data.dat) 2do 3 echo &amp;#34;${line}&amp;#34; 4done 如果输入文本每行中没有空格，则 line 在输入文本中按换行符分隔符循环取值。
如果输入文本中包括空格或制表符，则不是换行读取，line 在输入文本中按空格分隔符或制表符或换行符循环取值。
可以通过把 ${IFS} 设置为换行符来达到逐行读取的功能。
${IFS} 的默认值为：空白 （包括：空格，制表符，换行符）.</description>
    </item>
    
    <item>
      <title>Shell 使用模板文件生成文件</title>
      <link>https://csyakamoz.github.io/post/2020/09/09/shell-%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6/</link>
      <pubDate>Wed, 09 Sep 2020 11:13:35 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/2020/09/09/shell-%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6/</guid>
      <description>需求来源 有个模板文件，其占位符格式为：${variable}
现需要使用 shell 脚本来动态生成对应文件
实现 假设模板文件内容如下：
1#!/usr/bin/env bash 2 3version=&amp;#34;${version}&amp;#34; 4path=&amp;#34;${path}&amp;#34; 则动态生成对应文件的 shell 脚本可以如下：
1#!/usr/bin/env bash 2 3version=&amp;#34;1.0.0&amp;#34; 4path=&amp;#34;oh my god&amp;#34; 5 6sed \ 7 -e &amp;#34;s/\${version}/${version}/g&amp;#34; \ 8 -e &amp;#34;s/\${path}/${path}/g&amp;#34; \ 9 path_to_template_file \ 10 &amp;gt; path_to_output_file 需要注意的坑 一般我们使用 / 作为 sed 的定界符，但若变量值中包含 /, 则会导致 sed 解析失败
因此我们需要对 / 进行转义
1#!/usr/bin/env bash 2 3function handlingSlash() { 4 echo &amp;#34;$1&amp;#34; | sed -e &amp;#34;s/\//\\\\\//g&amp;#34; 5} 6 7version=&amp;#34;1.0.0&amp;#34; 8path=$(handlingSlash &amp;#34;${HOME}/Desktop/avatar.jpeg&amp;#34;) 9 10sed \ 11 -e &amp;#34;s/\${version}/${version}/g&amp;#34; \ 12 -e &amp;#34;s/\${path}/${path}/g&amp;#34; \ 13 path_to_template_file \ 14 &amp;gt; path_to_output_file 参考 How to replace ${} placeholders in a text file?</description>
    </item>
    
    <item>
      <title>Shell 打印彩色输出</title>
      <link>https://csyakamoz.github.io/post/2020/09/09/shell-%E6%89%93%E5%8D%B0%E5%BD%A9%E8%89%B2%E8%BE%93%E5%87%BA/</link>
      <pubDate>Wed, 09 Sep 2020 11:12:07 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/2020/09/09/shell-%E6%89%93%E5%8D%B0%E5%BD%A9%E8%89%B2%E8%BE%93%E5%87%BA/</guid>
      <description>格式说明 ESC[{attr1};...;{attrN}m
ESC: 转义字符，可选项为 \033, \x1b, \e 表示
m: 母鸡
attr: 控制代码（参见下方表格）
样例 简单的
1echo -e &amp;#34;\033[0;31mRed\033[0m&amp;#34; 2echo -e &amp;#34;\033[0;32mGreen\033[0m&amp;#34; 3 4echo -e &amp;#34;\033[1;31mHighlight Red\033[0m&amp;#34; 5echo -e &amp;#34;\033[1;3;31mHighlight Italic Red\033[0m&amp;#34; 6echo -e &amp;#34;\033[1;3;4;31mHighlight Italic Underline Red\033[0m&amp;#34; 完整的
1# https://askubuntu.com/questions/27314/script-to-display-all-terminal-colors 2for x in {0..8}; do 3 for i in {30..37}; do 4 for a in {40..47}; do 5 echo -ne &amp;#34;\e[$x;$i;$a&amp;#34;&amp;#34;m\\\e[$x;$i;$a&amp;#34;&amp;#34;m\e[0;37;40m &amp;#34; 6 done 7 echo 8 done 9done 10echo &amp;#34;&amp;#34; 参考 以下表格皆来自：ANSI 转义序列</description>
    </item>
    
    <item>
      <title>Shell 常用快捷键</title>
      <link>https://csyakamoz.github.io/post/2020/09/09/shell-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Wed, 09 Sep 2020 11:06:40 +0800</pubDate>
      
      <guid>https://csyakamoz.github.io/post/2020/09/09/shell-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description>Up, Ctrl + p, 向上移动光标或显示上一条命令
Down, Ctrl + n, 向下移动或显示下一条命令
Left, Ctrl + b, 光标向左移动一个字符
Right, Ctrl + f, 光标向右移动一个字符
BS, Ctrl + h, 删除光标左边的字符
Del, Ctrl + d, 删除光标右边的字符
Home, Ctrl + a, 跳转到行首
End, Ctrl + e, 跳转到行尾
 以上快捷键可在 Mac 中的大多数文本编辑区域使用
e.g.
 Google Chrome 的地址栏 Wechat 的聊天内容输入框   Ctrl + w, 删除光标左边一个单词
Alt + b, 光标向左移动一个单词
Alt + f, 光标向右移动一个单词
Alt + d, 删除光标右边的一个单词
Alt + BS, 删除光标左边的一个单词</description>
    </item>
    
  </channel>
</rss>
